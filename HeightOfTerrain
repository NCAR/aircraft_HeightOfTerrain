#! /usr/bin/env python3

import os
import gzip
import zipfile
import urllib.request
import numpy as np
import pandas as pd
import netCDF4
from scipy.interpolate import interp1d
import datetime
import argparse
import sys
import warnings

# Suppress only the np.bool deprecation warning from netCDF4
warnings.filterwarnings('ignore', message='.*np.bool.*', category=DeprecationWarning)

# Configuration
TdbData = "/scr/raf_data/TerrainData"
thisFileName = "HeightOfTerrain"

# Global cache for terrain tiles (like .GlobalEnv in R version)
# Key: tile name (e.g., "N40W105"), Value: 1201x1201 height array
_terrain_cache = {}

def datetoday():
    """Returns the current date in 'Day Month Year' format."""
    now = datetime.datetime.now()
    month_names = ["January", "February", "March", "April", "May", "June",
                   "July", "August", "September", "October", "November", "December"]
    return f"{now.day} {month_names[now.month - 1]} {now.year}"

def get_flight_bounds(nc_file_pattern):
    """Get lat/lon bounding box for flight(s) using flt_area utility.

    Calls the flt_area command-line utility to determine the geographic
    bounding box from NetCDF file attributes (geospatial_lat/lon_max/min).

    Args:
        nc_file_pattern: File pattern for NetCDF files (e.g., "/path/to/PROJECTrf*.nc")

    Returns:
        tuple: (lt_s, lt_n, lg_w, lg_e) - Southern lat, Northern lat, Western lon, Eastern lon
               All values are floored/ceiled integers, expanded by 1 degree for margin.
               Returns None if flt_area fails or is not available.

    Example:
        >>> bounds = get_flight_bounds("/data/SOCRATESrf*.nc")
        >>> print(bounds)  # (lt_s, lt_n, lg_w, lg_e)
        (-63, -41, 132, 164)
    """
    import subprocess
    import shutil

    # Check if flt_area utility is available
    if shutil.which('flt_area') is None:
        print("Warning: flt_area utility not found in PATH.")
        print("Cannot auto-determine lat/lon bounds. Please specify manually.")
        return None

    try:
        # Run flt_area command
        result = subprocess.run(
            ['flt_area', nc_file_pattern],
            capture_output=True,
            text=True,
            timeout=30
        )

        if result.returncode != 0:
            print(f"Error running flt_area: {result.stderr}")
            return None

        # Parse output - get last 4 lines containing the bounds
        lines = result.stdout.strip().split('\n')
        if len(lines) < 4:
            print("Error: flt_area output too short")
            return None

        # Get last 4 lines (like tail -4 in bash)
        last_4_lines = lines[-4:]

        # Parse the bounds from output format:
        # Maximum Latitude: -42.40082
        # Minimum Latitude: -61.997105
        # Minimum Longitude: 133.91486
        # Maximum Longitude: 163.02815

        # Combine into single string (like bash does)
        area_str = ' '.join(last_4_lines)
        parts = area_str.split()

        # Extract values at positions 2, 5, 8, 11 (colon-separated values)
        # When joined: "Maximum Latitude: -42.40082 Minimum Latitude: -61.997105 ..."
        # Position 0=Maximum, 1=Latitude:, 2=-42.40082, 3=Minimum, 4=Latitude:, 5=-61.997105, ...
        lat_max = float(parts[2])  # After "Maximum Latitude:"
        lat_min = float(parts[5])  # After "Minimum Latitude:"
        lon_min = float(parts[8])  # After "Minimum Longitude:"
        lon_max = float(parts[11]) # After "Maximum Longitude:"

        # Floor/ceil and expand by 1 degree (like bash script does)
        lt_s = int(np.floor(lat_min)) - 1
        lt_n = int(np.ceil(lat_max)) + 1
        lg_w = int(np.floor(lon_min)) - 1
        lg_e = int(np.ceil(lon_max)) + 1

        print(f"Auto-detected bounds from flt_area:")
        print(f"  Latitude:  {lt_s} to {lt_n}")
        print(f"  Longitude: {lg_w} to {lg_e}")

        return (lt_s, lt_n, lg_w, lg_e)

    except subprocess.TimeoutExpired:
        print("Error: flt_area command timed out")
        return None
    except (IndexError, ValueError) as e:
        print(f"Error parsing flt_area output: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error running flt_area: {e}")
        return None

def parse_args():
    parser = argparse.ArgumentParser(description='Process terrain height data.')
    parser.add_argument('Project', type=str, nargs='?', default='CAESAR', help='Project name')
    parser.add_argument('Flight', type=str, nargs='?', default='rf05', help='Flight number')
    parser.add_argument('Directory', type=str, nargs='?', default='.', help='Directory path')
    parser.add_argument('lt_s', type=int, nargs='?', default=None,
                       help='Southern latitude (auto-detected from NetCDF if not specified)')
    parser.add_argument('lt_n', type=int, nargs='?', default=None,
                       help='Northern latitude (auto-detected from NetCDF if not specified)')
    parser.add_argument('lg_w', type=int, nargs='?', default=None,
                       help='Western longitude (auto-detected from NetCDF if not specified)')
    parser.add_argument('lg_e', type=int, nargs='?', default=None,
                       help='Eastern longitude (auto-detected from NetCDF if not specified)')
    parser.add_argument('Tdb', type=str, nargs='?', default='yes', help='Terrain database flag')
    return parser.parse_args()

def HeightOfTerrain(lat, lon):
    """Get terrain height at given latitude/longitude coordinates.

    Uses a global cache to avoid reloading the same terrain tiles.
    This significantly speeds up processing when aircraft stays in same tile.

    Args:
        lat: Latitude in degrees (-90 to 90)
        lon: Longitude in degrees (-180 to 180)

    Returns:
        Height in meters, or np.nan if unavailable
    """
    # Check for masked values
    if np.ma.is_masked(lat) or np.ma.is_masked(lon):
        return np.nan
    # Check for NaN values BEFORE converting to int
    if np.isnan(lat) or np.isnan(lon):
        return np.nan

    lt = int(np.floor(lat))
    lg = int(np.floor(lon))
    NS = 'S' if lt < 0 else 'N'
    lt = abs(lt)
    EW = 'W' if lg < 0 else 'E'
    lg = abs(lg)
    vname = f"{NS}{lt:02d}{EW}{lg:03d}"

    # Check if tile is already in cache (like R's exists() check)
    if vname not in _terrain_cache:
        # Not cached - need to load it
        hgt_file = f"{vname}.hgt"

        # Search for the .hgt file in the subfolders
        for root, dirs, files in os.walk(TdbData):
            if hgt_file in files:
                hgt_file_path = os.path.join(root, hgt_file)
                try:
                    with open(hgt_file_path, 'rb') as f:
                        height = np.fromfile(f, dtype='>i2').astype(np.float32)
                    height[height == -32768] = np.nan
                    height = height.reshape(1201, 1201)

                    # Cache the loaded tile (like R's assign to .GlobalEnv)
                    _terrain_cache[vname] = height
                    break
                except FileNotFoundError as e:
                    print(e)
                    return np.nan
        else:
            # File not found in any subfolder
            print(f"File not found: {hgt_file}")
            return np.nan

    # Get height array from cache (like R's get(vname, envir=.GlobalEnv))
    height = _terrain_cache[vname]

    # Calculate indices and return height at that position
    ix = int((lon - np.floor(lon) + 1/2400) * 1200)
    iy = int((np.ceil(lat) - lat + 1/2400) * 1200)
    if np.ceil(lat) == lat:
        iy = 1200
    hgt = height[iy, ix]
    return hgt

def main():
    global TdbData
    args = parse_args()
    Project = args.Project
    Flight = args.Flight
    Directory = args.Directory
    lt_s = args.lt_s
    lt_n = args.lt_n
    lg_w = args.lg_w
    lg_e = args.lg_e
    Tdb = args.Tdb

    fname = f"{Directory}/{Project}{Flight}.nc"

    # Auto-detect lat/lon bounds if not specified using flt_area. User must have flt_area installed.
    if lt_s is None or lt_n is None or lg_w is None or lg_e is None:
        print(f"Lat/lon bounds not fully specified. Attempting auto-detection...")
        nc_pattern = f"{Directory}/{Project}[rtf]f??.nc"
        bounds = get_flight_bounds(nc_pattern)

        if bounds is None:
            print("Error: Could not auto-detect bounds and none were provided.")
            print("Please specify lat/lon bounds manually:")
            print("  HeightOfTerrain PROJECT FLIGHT DIRECTORY lt_s lt_n lg_w lg_e [Tdb]")
            sys.exit(1)

        lt_s, lt_n, lg_w, lg_e = bounds

    print(f"Processing {fname}")
    print(f"Using bounds: lat [{lt_s}, {lt_n}], lon [{lg_w}, {lg_e}]")
    lettr = '';
    numbr = '';
    if Tdb == "yes":
        if not os.path.exists(TdbData):
            ## If server terrain folder does not exist, store terrain data locally
            print(f"Creating Terrain Database folder in current directory: ./TerrainData")
            os.makedirs("./TerrainData", exist_ok=True)
            TdbData = "./TerrainData" # Change database path to local folder
        os.chdir(TdbData)
        for lt in range(lt_s, lt_n + 1):
            lettr = lt // 4 + 1
            NS = 'N' if lt >= 0 else 'S'
            if lg_w > lg_e:
                lrange = list(range(lg_w, 181)) + list(range(-180, lg_e + 1))
            else:
                lrange = range(lg_w, lg_e + 1)
            for lg in lrange:
                EW = 'E' if lg >= 0 else 'W'
                sname = f"Z{NS}{abs(lt)}{EW}{abs(lg):03d}.gz"
                dname = f"{NS}{abs(lt):02d}{EW}{abs(lg):03d}.hgt"
                
                numbr = 30 + lg // 6 + 1
                if lt < 0:
                    FileName = f"S{chr(ord('A') - lettr)}{numbr:02d}"
                else:
                    FileName = f"{chr(ord('A') + lettr - 1)}{numbr:02d}"
                if os.path.exists(FileName):
                    ## Don't redownload if the file already exists
                    #print(f"Terrain folder {FileName} exists, skipping download.")
                    continue
                else:
                    zipFileName = f"{FileName}.zip"
                    if not os.path.exists(zipFileName):
                        print("Downloading ", zipFileName)
                        url = f"http://www.viewfinderpanoramas.org/dem3/{zipFileName}"
                        try:
                            urllib.request.urlretrieve(url, zipFileName)
                        except urllib.error.URLError:
                            print(f"Could not download {zipFileName} from {url}")
                            continue
                    try:
                        if not os.path.exists(os.path.join(FileName, dname)):
                            with zipfile.ZipFile(zipFileName, 'r') as zip_ref:
                                zip_ref.extractall(TdbData)
                            print(f"Extracted {zipFileName}")
                        else:
                            print(f"{dname} already exists, skipping extraction.")
                    except zipfile.BadZipFile:
                        print(f"Bad zip file: {zipFileName}")
                        continue
                    if os.path.exists(dname):
                        with open(dname, 'rb') as f:
                            height = np.fromfile(f, dtype='>i2').astype(np.float32)
                        height[height == -32768] = np.nan
                        height = height.reshape(1201, 1201)
                        with gzip.open(sname, 'wb') as f:
                            np.save(f, height)
                        print(f"Saved {sname}")
                    

        os.chdir("..")
        print("Done loading Terrain Database")
        

    print(f"Writing Height of Terrain variables to {fname}")

    nc_data = netCDF4.Dataset(fname, 'r+')
    LATC = nc_data.variables['LATC'][:]
    LONC = nc_data.variables['LONC'][:]
    GGALT = nc_data.variables['GGALT'][:]
    GGLAT = nc_data.variables['GGLAT'][:]
    GGLON = nc_data.variables['GGLON'][:]
    Time = nc_data.variables['Time'][:]

    SFC = np.zeros(len(Time))
    for i in range(len(Time)):
        if np.isnan(LONC[i]) or np.isnan(LATC[i]):
            SFC[i] = HeightOfTerrain(GGLAT[i], GGLON[i])
        else:
            SFC[i] = HeightOfTerrain(LATC[i], LONC[i])

    if not np.all(np.isnan(SFC)):
        SFC_interp = interp1d(np.arange(len(SFC)), SFC, kind='linear', fill_value='extrapolate')
        valid_indices = ~np.isnan(SFC)
        SFC_valid = SFC[valid_indices]
        valid_times = np.arange(len(SFC))[valid_indices]
        SFC = SFC_interp(np.arange(len(SFC)))
        for i in range(len(SFC)):
            if np.isnan(SFC[i]):
                SFC[i] = 0
    SFC[np.isnan(SFC)] = 0
    ALTG = GGALT - SFC
    ##Create Variable if it does not exist
    if 'SFC_SRTM' not in nc_data.variables:
        nc_data.createVariable('SFC_SRTM', 'f4', ('Time',), fill_value=-9999)
    if 'ALTG_SRTM' not in nc_data.variables:
        nc_data.createVariable('ALTG_SRTM', 'f4', ('Time',), fill_value=-9999)

    nc_data.variables['SFC_SRTM'][:] = SFC
    nc_data.variables['ALTG_SRTM'][:] = ALTG
    nc_data.variables['SFC_SRTM'].setncattr('long_name', "Elevation of the Earth's surface below the aircraft position, WGS-84")
    nc_data.variables['SFC_SRTM'].setncattr('DataSource', 'viewfinderpanorama Jonathan de Ferranti')
    nc_data.variables['SFC_SRTM'].setncattr('Category', 'NavPosition')
    nc_data.variables['SFC_SRTM'].setncattr('Dependencies', '2 LATC LONC')
    minmax = f"{np.nanmin(SFC):.0f}f,{np.nanmax(SFC):.0f}f"
    nc_data.variables['SFC_SRTM'].setncattr('actual_range', minmax)
    nc_data.variables['SFC_SRTM'].setncattr('units', 'm')
    nc_data.variables['ALTG_SRTM'].setncattr('long_name', "Altitude of the aircraft above the Earth's surface, WGS-84")
    nc_data.variables['ALTG_SRTM'].setncattr('DataSource', 'viewfinderpanorama Jonathan de Ferranti')
    nc_data.variables['ALTG_SRTM'].setncattr('Category', 'NavPosition')
    nc_data.variables['ALTG_SRTM'].setncattr('units', 'm')
    nc_data.variables['ALTG_SRTM'].setncattr('Dependencies', '2 SFC_SRTM GGALT')
    minmax2 = f"{np.nanmin(ALTG):.0f}f,{np.nanmax(ALTG):.0f}f"
    nc_data.variables['ALTG_SRTM'].setncattr('actual_range', minmax2)


if __name__ == "__main__":
    main()